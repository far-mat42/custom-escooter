/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "stm32l4xx.h"

/* Function Prototypes -------------------------------------------------------*/
void initClocks(void);
void configGPIO(void);
void configSPI(void);
uint8_t readSPI(uint8_t addr);
uint8_t writeSPI(uint8_t addr, uint8_t tx_data);

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
	initClocks();
	configGPIO();
	configSPI();
}

/* Function definitions ------------------------------------------------------*/
void initClocks(void) {
	RCC->AHB2ENR |= 0x00000003; // Enable AHB2 peripheral clock for GPIOA and GPIOB
	RCC->APB2ENR |= 0x00001000;
}

void configGPIO(void) {
	// Resetting registers to be set later to ensure they are in a known state
	GPIOA->MODER &= (~(0x0000FC00));
	GPIOB->MODER &= (~(0x00000003));
	GPIOA->AFR[0] &= (~(0xFFF00000));
	GPIOB->AFR[0] &= (~(0x0000000F));

	GPIOA->MODER |= 0x0000A800; // Set PA5-7 to alternate function mode
	GPIOB->MODER |= 0x00000002; // Set PB0 to alternate function mode

	GPIOA->AFR[0] |= 0x55500000; // Set PA5-7 to AF5 (SPI1)
	GPIOB->AFR[0] |= 0x00000005; // Set PB0 to AF5 (SPI1)
}

void configSPI(void) {
	SPI1->CR1 &= (~(0x0003)); // Resetting CPOL and CPHA
	SPI1->CR1 &= (~(0x8400)); // Set to full duplex mode
	SPI1->CR1 &= (~(0x0080)); // Set to MSB first
	SPI1->CR1 &= (~(0x0038)); // Reset baud rate register to known state
	SPI1->CR1 &= (~(0x2000)); // Disable CRC calculation
	SPI1->CR1 &= (~(0x0200)); // Disable software slave management (hardware mode only)
	SPI1->CR1 |= 0x0010; // Set clock frequency to fPCLK/8 (500kHz)
	SPI1->CR1 |= 0x0004; // Set to master configuration

	SPI1->CR2 &= (~(0x1000)); // RXNE event triggers when FIFO level equals 16 bits (performing 16-bit transactions w/ AFE)
	SPI1->CR2 |= 0x0F00; // Set data length for SPI transfers to 16-bit
	SPI1->CR2 &= (~(0x00F0)); // Mask interrupts & set frame format to Motorola mode
	SPI1->CR2 |= 0x0004; // Enable slave select output
	SPI1->CR2 &= (~(0x0003)); // Disable DMA requests
}

uint8_t readSPI(uint8_t addr) {
	uint8_t rx_data = 0;

	SPI1->CR1 |= 0x0020; // Enable SPI, also pulls CS low

	// Shift in address & dummy byte (0x00) into data frame
	SPI1->DR = (uint16_t)(addr << 8);
	SPI1->DR |= 0x8000; // Set the R/W bit high to indicate a read

	// Tight poll until SPI not busy and RX buffer is not empty
	while ( ((SPI1->SR) & 0x0080) || (!((SPI1->SR) & 0x0001)) ) {}

	rx_data = (uint8_t)SPI1->DR; // Store data from SPI RX buffer

	SPI1->CR1 &= (~(0x0020)); // Disable SPI, also pulls CS high

	return rx_data;
}

uint8_t writeSPI(uint8_t addr, uint8_t tx_data) {
	SPI1->CR1 |= 0x0020; // Enable SPI, also pulls CS low

	// Shift in address & tx_data into data frame
	SPI1->DR = (uint16_t)(addr << 8);
	SPI1->DR |= (uint16_t)(tx_data);
	SPI1->DR &= (~(0x8000)); // Set the R/W bit low to indicate a write
	// Tight poll until SPI not busy and TX buffer is not empty
	while ( ((SPI1->SR) & 0x0080) || ((SPI1->SR) & 0x0002) ) {}
}
