/*
 * bq76952.c
 * Implements the helper functions required to communicate with the BQ76952 AFE
 *  Created on: Jul 7, 2024
 *      Author: farri
 */

#include "bq76952.h"
#include "stm32l4xx_hal.h"
#include <stdbool.h>

uint8_t crc8(uint8_t *data, size_t len)
{
    uint8_t crc = 0x00;
    while (len--)
    {
        crc ^= *data++;
        for (uint8_t i = 0; i < 8; ++i)
        {
            if (crc & 0x80)
                crc = (crc << 1) ^ 0x07; // Polynomial 0x07
            else
                crc <<= 1;
        }
    }
    return crc;
}

/**
 * Sends a direct command to the AFE and reads the data that is output
 * @param cmd The address byte for the command
 * @param returnData Pointer to the 8-bit integer array for storing the read data
 * @param len Number of bytes to read from the AFE. The function automatically increments the address byte based on this value
 */
void DirectCmdRead(uint8_t cmd, uint8_t *returnData, uint8_t len)
{
	uint8_t rxData[3] = {0};
	uint8_t txData[3] = {0};
	uint8_t fullCmd[] = { cmd, 0xFF }; // Data byte doesn't matter since it's a read, just use 0xFF
	uint8_t crcLower = 0;
//	bool commReceived = false;

	// Increment the command address based on the data length given
	for (int i = 0; i < len; i++)
	{
		fullCmd[0] = cmd + i; // Increment the address
		crcLower = crc8(fullCmd, 2); // Recalculate the CRC
		// Construct the TX data for the SPI transaction
		txData[0] = fullCmd[0];
		txData[1] = fullCmd[1];
		txData[2] = crcLower;

		AFETransmitReadCmd(txData, rxData, sizeof(txData));
		returnData[i] = rxData[1]; // Save data byte received from last transaction
	}
}

/**
 * Sends a sub-command to the AFE, no data is written or read
 * @param cmd The upper and lower address bytes for the sub-command
 */
void SubCmdNoData(uint16_t cmd)
{
	uint8_t rxData[3] = {0};
	uint8_t commandLowerAddr[] = { LOWER_ADDR_REG_WRITE, ((uint8_t)(cmd & 0xFF)) };
	uint8_t crcLower = crc8(commandLowerAddr, 2);
	uint8_t commandUpperAddr[] = { UPPER_ADDR_REG_WRITE, ((uint8_t)(cmd >> 8)) };
	uint8_t crcUpper = crc8(commandUpperAddr, 2);

	// Keep writing the command until MISO reflects command was received
	// Starting with lower byte
	uint8_t txData[] = { commandLowerAddr[0], commandLowerAddr[1], crcLower };
	AFETransmitWriteCmd(txData, rxData, sizeof(txData));

	// Continue to upper byte
	txData[0] = commandUpperAddr[0];
	txData[1] = commandUpperAddr[1];
	txData[2] = crcUpper;
	AFETransmitWriteCmd(txData, rxData, sizeof(txData));
}

/**
 * Sends a sub-command to the AFE and reads the data that is output
 * @param cmd The upper and lower address bytes for the sub-command
 * @param returnData Pointer to the 8-bit integer array for storing the read data
 * @param len Number of bytes to read from the AFE's 32-byte data buffer
 */
void SubCmdReadData(uint16_t cmd, uint8_t *returnData, uint8_t len)
{
	uint8_t rxData[3] = {0};
	uint8_t commandLowerAddr[] = { LOWER_ADDR_REG_WRITE, ((uint8_t)(cmd & 0xFF)) };
	uint8_t crcLower = crc8(commandLowerAddr, 2);
	uint8_t commandUpperAddr[] = { UPPER_ADDR_REG_WRITE, ((uint8_t)(cmd >> 8)) };
	uint8_t crcUpper = crc8(commandUpperAddr, 2);

	// Keep writing the command until MISO reflects command was received
	// Starting with lower byte
	uint8_t txData[] = { commandLowerAddr[0], commandLowerAddr[1], crcLower };
	AFETransmitWriteCmd(txData, rxData, sizeof(txData));

	// Continue to upper byte
	txData[0] = commandUpperAddr[0];
	txData[1] = commandUpperAddr[1];
	txData[2] = crcUpper;
	AFETransmitWriteCmd(txData, rxData, sizeof(txData));

	// Read each byte based on the data length given in parameters
	uint8_t readData[2] = {0};
	for (int i = 0; i < len; i++) {
		readData[0] = READ_DATA_BUFF_LSB + i;
		readData[1] = 0xFF;

		txData[0] = readData[0];
		txData[1] = readData[1];
		txData[2] = crc8(readData, 2);

		AFETransmitReadCmd(txData, rxData, sizeof(txData));

		returnData[i] = rxData[1]; // Save data byte received from last transaction
	}
}

/**
 * Reads the value stored in one of the AFE's RAM registers
 * Might remove this function, it's exactly the same as the SubCmd read data function
 * @param addr The register address
 * @param returnData Pointer to the 8-bit integer array for storing the read data
 * @param len Number of bytes to read from the AFE's 32-byte data buffer
 */
void RAMRegisterRead(uint16_t addr, uint8_t *returnData, uint8_t len)
{
	// Preparing the SPI transaction to send to tell the AFE a RAM register read is happening
	uint8_t rxData[3] = {0};
	uint8_t commandLowerAddr[] = { LOWER_ADDR_REG_WRITE, ((uint8_t)(addr & 0xFF)) };
	uint8_t crcLower = crc8(commandLowerAddr, 2);
	uint8_t commandUpperAddr[] = { UPPER_ADDR_REG_WRITE, ((uint8_t)(addr >> 8)) };
	uint8_t crcUpper = crc8(commandUpperAddr, 2);
//	bool commReceived = false;

	// Keep writing the command until MISO reflects command was received
	// Starting with lower byte
	uint8_t txData[] = { commandLowerAddr[0], commandLowerAddr[1], crcLower };
//	while (!commReceived)
//	{
//		// Pull NSS low
//		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
//		// Transmit data and receive AFE's response
//		HAL_SPI_TransmitReceive(&hspi1, txData, rxData, sizeof(txData), HAL_MAX_DELAY);
//
//		// Confirm command was received
//		commReceived = true;
//		for (int i = 0; i < sizeof(txData); i++)
//		{
//			if (txData[i] != rxData[i]) commReceived = false; // If any mismatch occurs, flag it and retransmit
//		}
//		// Pull NSS high and wait for transaction to be processed
//		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
//		HAL_Delay(3);
//	}
	AFETransmitWriteCmd(txData, rxData, sizeof(txData));

	// Continue to upper byte
	txData[0] = commandUpperAddr[0];
	txData[1] = commandUpperAddr[1];
	txData[2] = crcUpper;
//	commReceived = false;
//	while (!commReceived)
//	{
//		// Pull NSS low
//		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
//
//		// Transmit data and receive AFE's response
//		HAL_SPI_TransmitReceive(&hspi1, txData, rxData, sizeof(txData), HAL_MAX_DELAY);
//
//		// Confirm command was received
//		commReceived = true;
//		for (int i = 0; i < sizeof(txData); i++)
//		{
//			if (txData[i] != rxData[i]) commReceived = false; // If any mismatch occurs, flag it and retransmit
//		}
//		// Pull NSS high and wait for transaction to be processed
//		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
//		HAL_Delay(3);
//	}
	AFETransmitWriteCmd(txData, rxData, sizeof(txData));

	// Read each byte based on the data length given in parameters
	uint8_t readData[2] = {0};
	for (int i = 0; i < len; i++) {
		readData[0] = READ_DATA_BUFF_LSB + i;
		readData[1] = 0xFF;

		txData[0] = readData[0];
		txData[1] = readData[1];
		txData[2] = crc8(readData, 2);

//		commReceived = false;
//		while (!commReceived)
//		{
//			// Pull NSS low
//			HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
//
//			// Transmit data and receive AFE's response
//			HAL_SPI_TransmitReceive(&hspi1, txData, rxData, sizeof(txData), HAL_MAX_DELAY);
//
//			// Confirm command was received by checking address byte received
//			if (txData[0] == rxData[0]) commReceived = true;
//			// Pull NSS high and wait for transaction to be processed
//			HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
//			HAL_Delay(3);
//		}
		AFETransmitReadCmd(txData, rxData, sizeof(txData));

		returnData[i] = rxData[1]; // Save data byte received from last transaction
	}
}

/**
 * Writes the given value in one of the AFE's RAM registers
 * Might remove this function, it's exactly the same as the SubCmd read data function
 * @param addr The register address
 * @param writeData Pointer to the 8-bit integer array for the data to write to the register
 * @param len Number of bytes to write to the AFE's 32-byte data buffer
 */
void RAMRegisterWrite(uint16_t addr, uint8_t *writeData, uint8_t len)
{
	uint8_t rxData[3] = {0};
	uint8_t lowerAddr[] = { LOWER_ADDR_REG_WRITE, ((uint8_t)(addr & 0xFF)) };
	uint8_t crcLower = crc8(lowerAddr, 2);
	uint8_t upperAddr[] = { UPPER_ADDR_REG_WRITE, ((uint8_t)(addr >> 8)) };
	uint8_t crcUpper = crc8(upperAddr, 2);
//	bool commReceived = false;

	// Keep writing the register address until MISO reflects command was received
	// Starting with lower byte
	uint8_t txData[] = { lowerAddr[0], lowerAddr[1], crcLower };
//	while (!commReceived)
//	{
//		// Pull NSS low
//		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
//		// Transmit data and receive AFE's response
//		HAL_SPI_TransmitReceive(&hspi1, txData, rxData, sizeof(txData), HAL_MAX_DELAY);
//
//		// Confirm address byte was received
//		commReceived = true;
//		for (int i = 0; i < sizeof(txData); i++)
//		{
//			if (txData[i] != rxData[i]) commReceived = false; // If any mismatch occurs, flag it and retransmit
//		}
//		// Pull NSS high and wait for transaction to be processed
//		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
//		HAL_Delay(1);
//	}
	AFETransmitWriteCmd(txData, rxData, sizeof(txData));

	// Continue to upper byte
	txData[0] = upperAddr[0];
	txData[1] = upperAddr[1];
	txData[2] = crcUpper;
//	commReceived = false;
//	while (!commReceived)
//	{
//		// Pull NSS low
//		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
//
//		// Transmit data and receive AFE's response
//		HAL_SPI_TransmitReceive(&hspi1, txData, rxData, sizeof(txData), HAL_MAX_DELAY);
//
//		// Confirm address byte was received
//		commReceived = true;
//		for (int i = 0; i < sizeof(txData); i++)
//		{
//			if (txData[i] != rxData[i]) commReceived = false; // If any mismatch occurs, flag it and retransmit
//		}
//		// Pull NSS high and wait for transaction to be processed
//		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
//		HAL_Delay(1);
//	}
	AFETransmitWriteCmd(txData, rxData, sizeof(txData));

	// Write the data provided to the AFE's 32-byte data buffer
	uint8_t writeBytes[2] = {0};
	for (int i = 0; i < len; i++)
	{
		// Increment data buffer address and include the next address byte
		writeBytes[0] = WRITE_DATA_BUFF_LSB + i;
		writeBytes[1] = writeData[i];

		txData[0] = writeBytes[0];
		txData[1] = writeBytes[1];
		txData[2] = crc8(writeBytes, 2); // Recalculate CRC

//		commReceived = false;
//		while (!commReceived)
//		{
//			// Pull NSS low
//			HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
//			// Transmit data and receive AFE's response
//			HAL_SPI_TransmitReceive(&hspi1, txData, rxData, sizeof(txData), HAL_MAX_DELAY);
//
//			// Confirm write data was received
//			commReceived = true;
//			for (int i = 0; i < sizeof(txData); i++)
//			{
//				if (txData[i] != rxData[i]) commReceived = false; // If any mismatch occurs, flag it and retransmit
//			}
//
//			// Pull NSS high and wait for transaction to be processed
//			HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
//			HAL_Delay(1);
//		}
		AFETransmitWriteCmd(txData, rxData, sizeof(txData));
	}

	// Calculate the check-sum and write it to the AFE's checksum register
	uint8_t checkSum = 0;
	for (int i = 0; i < len; i++) {
		checkSum += writeData[i];
	}
	checkSum += lowerAddr[1];
	checkSum += upperAddr[1];

	writeBytes[0] = WRITE_CHECKSUM_ADDR;
	writeBytes[1] = checkSum;

	txData[0] = writeBytes[0];
	txData[1] = writeBytes[1];
	txData[2] = crc8(writeBytes, 2); // Recalculate CRC

	AFETransmitWriteCmd(txData, rxData, sizeof(txData));
//	commReceived = false;
//	while (!commReceived)
//	{
//		// Pull NSS low
//		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
//		// Transmit data and receive AFE's response
//		HAL_SPI_TransmitReceive(&hspi1, txData, rxData, sizeof(txData), HAL_MAX_DELAY);
//
//		// Confirm write data was received
//		commReceived = true;
//		for (int i = 0; i < sizeof(txData); i++)
//		{
//			if (txData[i] != rxData[i]) commReceived = false; // If any mismatch occurs, flag it and retransmit
//		}
//
//		// Pull NSS high and wait for transaction to be processed
//		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
//		HAL_Delay(1);
//	}

	// Write the data length to the AFE's data length register
	writeBytes[0] = WRITE_DATALEN_ADDR;
	writeBytes[1] = len + 4; // Length of data buffer, plus upper and lower address bytes, plus checksum and data length bytes

	txData[0] = writeBytes[0];
	txData[1] = writeBytes[1];
	txData[2] = crc8(writeBytes, 2); // Recalculate CRC

	AFETransmitWriteCmd(txData, rxData, sizeof(txData));
//	commReceived = false;
//	while (!commReceived)
//	{
//		// Pull NSS low
//		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
//		// Transmit data and receive AFE's response
//		HAL_SPI_TransmitReceive(&hspi1, txData, rxData, sizeof(txData), HAL_MAX_DELAY);
//
//		// Confirm write data was received
//		commReceived = true;
//		for (int i = 0; i < sizeof(txData); i++)
//		{
//			if (txData[i] != rxData[i]) commReceived = false; // If any mismatch occurs, flag it and retransmit
//		}
//
//		// Pull NSS high and wait for transaction to be processed
//		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
//		HAL_Delay(1);
//	}
}

void AFETransmitReadCmd(uint8_t *txBytes, uint8_t *rxBytes, uint8_t arrSize)
{
	// Continuously transmit the SPI transaction until the AFE has received it
	bool commReceived = false;
	while (!commReceived)
	{
		// Pull NSS low
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
		// Transmit data and receive AFE's response
		HAL_SPI_TransmitReceive(&hspi1, txBytes, rxBytes, arrSize, HAL_MAX_DELAY);

		// For read command, confirm the AFE received the command by checking the address and CRC bytes
		if (txBytes[0] == rxBytes[0]) commReceived = true;
		// TODO: implement CRC checking for received data

		// Pull NSS high and wait for transaction to be processed
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
		HAL_Delay(1);
	}

}

void AFETransmitWriteCmd(uint8_t *txBytes, uint8_t *rxBytes, uint8_t arrSize)
{
	// Continuously transmit the SPI transaction until the AFE has received it
	bool commReceived = false;
	while (!commReceived)
	{
		// Pull NSS low
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
		// Transmit data and receive AFE's response
		HAL_SPI_TransmitReceive(&hspi1, txBytes, rxBytes, arrSize, HAL_MAX_DELAY);

		// For write command, confirm the AFE received the command by checking every single byte
		commReceived = true;
		for (int i = 0; i < arrSize; i++)
		{
			if (txBytes[i] != rxBytes[i]) commReceived = false; // If any mismatch occurs, flag it and retransmit
		}

		// Pull NSS high and wait for transaction to be processed
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
		HAL_Delay(1);
	}
}
